# 1. В чём разница между процессами и потоками?
```bash
# Процесс — это как отдельная программа.
# Поток — это как маленький помощник внутри программы, который делает работу параллельно.
```

# 2. Какие есть способы создания потоков в Java? Чем Thread отличается от Runnable?
```bash 
# Поток можно сделать двумя способами:
# - через класс Thread
# - через интерфейс Runnable
# Разница: Thread запускает, а Runnable только говорит, ЧТО делать.
```

# 3. Для чего нужно слово synchronized? Какие его минусы?
```bash
# Оно не даёт двум потокам одновременно трогать одну и ту же переменную.
# Минус — другие потоки в это время ждут, и программа тормозит.
```

# 4. Чем AtomicLong отличается от обычного long?
```bash
# Обычный long может глючить, если его трогают сразу несколько потоков.
# AtomicLong защищён — можно менять без конфликтов.
```

# 5. Что такое ExecutorService? Почему он лучше ручных потоков?
```bash
# Это “менеджер”, который сам создаёт, запускает и завершает потоки.
# Удобнее, потому что не нужно всё делать руками.
```

# 6. Чем Runnable отличается от Callable?
```bash
# Runnable просто запускается и ничего не возвращает.
# Callable возвращает результат (например, сумму чисел).
```

# 7. Зачем нужен метод Future.get()? Что будет, если его не вызвать?
```bash
# Future.get() ждёт, пока поток закончит, и даёт результат.
# Если не вызвать — поток отработает, но ты не узнаешь, что он посчитал.
```

# 8. Чем ExecutorService отличается от CompletionService?
```bash
# ExecutorService ждёт всех и потом даёт результаты.
# CompletionService выдаёт готовые результаты по мере их появления.

```

# 9. Почему CompletionService выдаёт в разном порядке?
```bash`
# Потому что потоки заканчивают работу в разное время — кто успел, тот и молодец.
``

# 10. Как сделать тайм-аут и зачем он нужен?
```bash
# future.get(5, TimeUnit.SECONDS)
# Это значит: подожди максимум 5 секунд, а потом прекращай ждать.
# Нужно, чтобы программа не зависала.
```

# 11. Для чего нужен CyclicBarrier? Чем он отличается от CountDownLatch?
```bash
# CyclicBarrier ждёт всех потоков, потом даёт им команду "идём дальше".
# CountDownLatch просто считает, сколько потоков закончило — и всё, одноразовый.
```

# 12. Что будет, если один поток не дойдёт до барьера?
```bash
# Все остальные будут стоять и ждать вечно.
```

# 13. Когда CyclicBarrier удобен?
```bash
# Когда все потоки должны сделать шаг 1, потом вместе перейти на шаг 2.

```

# 14. Почему ExecutorService быстрее обычных потоков?
```bash
# Потому что он использует одни и те же потоки много раз, не создавая новые.
```

# 15. Как количество потоков влияет на скорость?
```bash
# Немного потоков — работает быстрее.
# Слишком много — компьютер не справляется, начинает лагать.
```

# 16. Что будет, если потоков слишком много?
```bash
# Компьютер устанет: начнёт тормозить, греться и может зависнуть.
```
